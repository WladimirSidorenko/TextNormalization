#!/usr/bin/env python2.7
# -*- coding: utf-8; -*-

"""
Script for evaluating CRF model.
"""

##################################################################
# Libraries
from alt_argparse  import argparser
from alt_fio import AltFileInput, AltFileOutput

import re
import os
import sys
import string

##################################################################
# Constants and Variables
STAT = dict()

# field names for proportional match evaluation
GOLD_INTERSECT_SCORE = 0        # intersection score for gold spans
GOLD_SPANS_CNT = 1              # number of spans in gold annotation
PRDCT_INTERSECT_SCORE = 2        # intersection score for automatically annotated spans
PRDCT_SPANS_CNT = 3              # number of spans in automatic annotation

# flags indicating which span should be updated
GOLD_SPAN = 1
PRDCT_SPAN = 2
ALL_SPANS = GOLD_SPAN | PRDCT_SPAN

#  regular expressions for capturing features and words
PUNCT_RE = re.compile(r"^(?:" + '|'.join([re.escape(c) for c in string.punctuation]) + ")+$")
FORM_FEAT_RE = re.compile(r"form\[0\]=(\S+)")
EOS_RE = re.compile(r"(?:\b|^)__EOS__(?:\b|$)")

prev_gld_tag = ""
prev_prdct_tag = ""

gld_span_card = 0
prdct_span_card = 0
gld_intersect_card = 0
prdct_intersect_card = 0

##################################################################
# Methods
def _update_stat(a_tag, a_class, a_arg = 1):
    """Update global statistics on tags."""
    global STAT
    if not a_tag:
        return
    if a_tag not in STAT:
        if args.exact:
            STAT[a_tag] = [0, 0, 0]
        else:
            STAT[a_tag] = [0, 0, 0, 0]
    STAT[a_tag][a_class] += a_arg

def _get_trg_tag(a_tag):
    """Get target tag for given tag."""
    if a_tag and a_tag[0] == 'B':
        return a_tag[1:]
    else:
        return a_tag

def _calc_exact_score(a_intersect, a_total):
    """Estimate exact overlapping score.

    @param a_intersect  - number of tokens with matching annotation
    @param a_total      - total number of tokens in span

    @return 1 if all tokens in span agree on tagging

    """
    raise NotImplementedError

def _calc_proportional_score(a_intersect, a_total):
    """Estimate proportional overlapping score.

    @param a_intersect  - number of tokens with matching annotation
    @param a_total      - total number of tokens in span

    @return proportion of tokens with matching annotation

    """
    if a_total == 0:
        return a_total
    else:
        return float(a_intersect) / a_total

def _calc_binary_score(a_intersect, a_total):
    """Estimate binary overlapping score.

    @param a_intersect  - number of tokens with matching annotation
    @param a_total      - total number of tokens in span

    @return 1 if at least one token intersects with the span

    """
    if a_total == 0 or a_intersect == 0:
        return 0
    else:
        return 1

def finalize_spans(a_span_type = 0):
    """Finalize spans of specific types."""
    # source and target spans imply the existence of a sentiment span
    # update gold spans if necessary
    if a_span_type & GOLD_SPAN:
        global prev_gld_tag, gld_intersect_card, gld_span_card
        if gld_span_card:
            gld_tag = _get_trg_tag(prev_gld_tag)
            _update_stat(gld_tag, GOLD_INTERSECT_SCORE, \
                             calc_score(gld_intersect_card, gld_span_card))
            # remember that new span has started
            _update_stat(gld_tag, GOLD_SPANS_CNT)
        gld_span_card = gld_intersect_card = 0
    # update predicted spans if necessary
    if a_span_type & PRDCT_SPAN:
        global prev_prdct_tag, prdct_intersect_card, prdct_span_card
        if prdct_span_card:
            prdct_tag = _get_trg_tag(prev_prdct_tag)
            _update_stat(prdct_tag, PRDCT_INTERSECT_SCORE, \
                             calc_score(prdct_intersect_card, prdct_span_card))
            _update_stat(prdct_tag, PRDCT_SPANS_CNT)
        prdct_span_card = prdct_intersect_card = 0

def calc_stat(a_gld_tag, a_prdct_tag):
    """Calculate binary/proportional overlap of tagging spans."""
    global STAT, prev_gld_tag, prev_prdct_tag, \
        gld_span_card, prdct_span_card, gld_intersect_card, prdct_intersect_card
    # convert introductory tags (those starting with an `I') to regular ones
    # (by stripping off the initial `I')
    trg_gld_tag = _get_trg_tag(a_gld_tag)
    trg_prdct_tag = _get_trg_tag(a_prdct_tag)
    # if span introduced by the previous reference tag continues here, we keep
    # incrementing the length of the span
    if prev_gld_tag and (prev_gld_tag == a_gld_tag or \
                             _get_trg_tag(prev_gld_tag) == a_gld_tag):
        gld_span_card += 1
    # otherwise, increment the counter of the spans
    else:
        # update the statistics for previously ended span
        finalize_spans(GOLD_SPAN)
        gld_span_card = 1

    # we apply the same procedure for the automatically predicted tags
    if prev_prdct_tag and (prev_prdct_tag == a_prdct_tag or \
                              _get_trg_tag(prev_prdct_tag) == a_prdct_tag):
        prdct_span_card += 1
    # otherwise, increment the counter of the spans
    else:
        finalize_spans(PRDCT_SPAN)
        prdct_span_card = 1
    # check whether automatically assigned tag and the reference tags are the
    # same and increment intersection counters if they are
    if trg_gld_tag == trg_prdct_tag:
        gld_intersect_card += 1
        prdct_intersect_card += 1
    # remember gold and predicted tags
    prev_gld_tag, prev_prdct_tag = a_gld_tag, a_prdct_tag

def output_stat(a_foutput):
    """Output tagging statistics for binary/proportional overlap."""
    global STAT
    # output header
    a_foutput.fprint("{:<10s}{:>10s}{:>10s}{:>10s}".format("Tag", "Precision", "Recall", "F-Measure"))
    # output statistics on each tag
    prec = rcall = fscore = 0.0
    gld_intersect = gld_span_card = 0
    prdct_intersect = prdct_span_card = 0
    stat_list = None
    for tag in sorted(STAT.iterkeys()):
        stat_list = STAT[tag]
        gld_intersect = stat_list[GOLD_INTERSECT_SCORE] # number of matched gold spans/span tokens
        gld_span_card = stat_list[GOLD_SPANS_CNT] # number of gold spans with given tag
        prdct_intersect = stat_list[PRDCT_INTERSECT_SCORE] # number of matched predicted spans/span tokens
        prdct_span_card = stat_list[PRDCT_SPANS_CNT] # number of predicted spans with given tag
        prec = float(prdct_intersect) * 100 / prdct_span_card if prdct_span_card else 0.0
        rcall = float(gld_intersect) * 100 / gld_span_card if gld_span_card else 0.0
        fscore = 2 * prec * rcall / (prec + rcall) if prec or rcall else 0.0
        a_foutput.fprint("{tag:<10s}{prec:>9.2f}%{rcall:>9.2f}%{fscore:>9.2f}%".format(**locals()))

##################################################################
# Arguments
argparser.description="""Script for evaluating the results of automatic tagging."""
argparser.add_argument("-b", "--binary", help = """consider tagging of two
compared spans as correct if they agree on the tagging of at least one word (default)""", \
                           action = "store_true")
argparser.add_argument("-x", "--exact", help = """consider tagging of two
compared spans as correct if they agree on tagging of all words (NOT IMPLEMENTED)""", \
                           action = "store_true")
argparser.add_argument("-p", "--proportional", help = """estimate tagging
quality of two compared spans proportionally to the number of overlapping tags (cf.
Johansson and Moschitti, CoNLL 2010)""", \
                           action = "store_true")
argparser.add_argument("--punct", help = """consider punctuation marks during estimation""", \
                           action = "store_true")
args = argparser.parse_args()
skip_punct = not args.punct

# determine appropriate estimation function
calc_score = _calc_binary_score

if args.exact:
    raise NotImplementedError
elif args.proportional:
    calc_score = _calc_proportional_score

##################################################################
# Main
foutput = AltFileOutput(encoding = args.encoding, flush = args.flush)
finput = AltFileInput(*args.files, encoding = args.encoding, \
                           print_func = foutput.fprint)

gld_tag = prdct_tag = word = ""
mobj = None

for line in finput:
    # skip empty lines
    if not line:
        finalize_spans(ALL_SPANS)
        continue
    # split line in words
    words = line.split()
    assert len(words) > 2, "Unrecognized line format: '{:s}'".format(line)
    # obtain tags
    gld_tag, prdct_tag = words[:2]
    # obtain input word
    mobj = FORM_FEAT_RE.search(line)
    assert mobj, "Reference word not found"
    word = mobj.group(1)
    # prdct_tag, gld_tag, word
    if skip_punct and PUNCT_RE.match(word):
        continue
    calc_stat(gld_tag, prdct_tag)
    if EOS_RE.search(line):
        finalize_spans(ALL_SPANS)

# update counters for the last detected spans
finalize_spans(ALL_SPANS)

# print statistics
output_stat(foutput)
