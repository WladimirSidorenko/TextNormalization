#!/usr/bin/env python2.7
# -*- coding: utf-8; -*-

##################################################################
# Libraries
import tokenizer
from ld.edseg import EDSSegmenter
from conll import CONLLSentence, CONLLWord
from alt_argparse  import argparser
from alt_fio import AltFileInput, AltFileOutput

import re
import os
import sys

##################################################################
# Constants and Variables
iSentence = CONLLSentence()
iSegmenter = EDSSegmenter()

##################################################################
# Methods
def output_sentence():
    """Split sentence in elementary discourse units and output it."""
    global iSentence
    if iSentence.is_empty():
        return
    else:
        sds = iSegmenter.segment(iSentence)
        sds.pretty_print()
        iSentence.clear()

##################################################################
# Arguments
argparser.description="Script for segmenting sentences into elementary discourse units."
argparser.add_argument("-c", "--esc-char", help = """escape character which should
precede lines with meta-information""", nargs = 1, type = str, \
                           default = os.environ.get("SOCMEDIA_ESC_CHAR", ""))
argparser.add_argument("-t", "--eos-tag", help = """tag for marking sentence boundary""", \
                           default = tokenizer.EOS_TAG)
args = argparser.parse_args()

##################################################################
# Main Body
ESC_CHAR = args.esc_char
EOS_TAG = args.eos_tag
skip_line = args.skip_line
foutput   = AltFileOutput(encoding = args.encoding, \
                              flush = args.flush)
finput    = AltFileInput(*args.files, print_func = foutput.fprint)

for line in finput:
    # print empty and skip lines unchanged
    if not line or line == skip_line or \
            line[0] == ESC_CHAR or line == EOS_TAG:
        # print sentence
        output_sentence()
        # check if memory is empty and print it otherwise
        foutput.fprint(line)
    # otherwise, line is a normal line and its umlauts should be restored with
    # update of replacement information
    else:
        # append word to CONLL sentence
        iSentence.push_word(CONLLWord(line))
# output sentence
output_sentence()
