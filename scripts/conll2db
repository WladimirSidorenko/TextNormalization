#!/usr/bin/env python2.7
# -*- coding: utf-8; -*-

"""
This script converts the CONLL format used for representing dependency grammar
trees to DB format which is used by Markov Logic Network Inference.

"""

##################################################################
# Libraries
import sys
import os
import re

from conll import CONLL, CONLLWord, FEAT_NAME_SEP
from alt_argparse  import argparser
from alt_fio import AltFileInput, AltFileOutput

##################################################################
# Constants
FEAT_NAME_SEP_RE = re.compile(re.escape(FEAT_NAME_SEP))
CONLL_FIELD_SEP = '\t'

QUOTE_RE = re.compile(r'(["])')
BCKSL_RE = re.compile(r'(\\+)$')

TKN_ID_SEP = '_'
TKN_PRFX_TRAIN = "W_"
TKN_PRFX_TEST  = "X_"

IS_FEAT_PRFX = "is"
HAS_FEAT_PRFX = "has"

tknprfx = TKN_PRFX_TRAIN
sentiment_seen = False

# ROOT_NODE = r"""Lemma("W_{r_id:s}_-1", "ROOT")
# Form("W_{r_id:s}_-1", "ROOT")
# Tag("W_{r_id:s}_-1", NN)"""

ROOT_NODE = r"""Tag("W_{r_id:s}_-1", NN)"""

##################################################################
# Methods
def escape_word(iword):
    """Escape all quotes in iword and surround it with quotes."""
    iword = QUOTE_RE.sub(r"\\\1", iword)
    iword = BCKSL_RE.sub(r"BACKSLASH", iword)
    return '"' + iword + '"'

def translate_tag(itag):
    """Return tag unchanged unless it consists of punct characters."""
    if itag == "$.":
        return "TPUNCT"
    elif itag == "$,":
        return "TCOMMA"
    elif itag == "$(":
        return "TBRACE"
    return itag

def translate_connector(iconnector):
    """Return argument string unchanged unless it is equal to `--'."""
    if iconnector == "--":
        return "CPUNCT"
    return iconnector

def __print_mln__(foutput, tkn_id, prnt_id, conll_w):
    """Output data in MLN format."""
    # # output lemma
    # foutput.fprint("Lemma" + '("' + tkn_id + '", ' + escape_word(conll_w.lemma.lower()) + ")")
    # # output form
    # foutput.fprint("Form" + '("' + tkn_id + '", ' + escape_word(conll_w.form.lower()) + ")")
    # output tag
    foutput.fprint("Tag" + '("' + tkn_id + '", ' + translate_tag(conll_w.pos) + ')')
    # output connector
    foutput.fprint("Connector" + '("' + prnt_id + '", "' + tkn_id + '", ' + \
                       translate_connector(conll_w.pdeprel) + ")")
    # output features
    for fname, fvalue in conll_w.pfeatures.iteritems():
        if fvalue == '*':
            fvalue = "ANY"
        __print_feat_func__(foutput, tkn_id, fname, fvalue)

def __print_feat_mln_train__(foutput, tkn_id, fname, fvalue):
    """Output features from training corpus."""
    # check if feature comes from MMAX annotation and apply appropriate
    # conversion to it.  MMAX annotations should have the form
    # Sentiment::markable_141::Sentiment=True which should be transformed to
    # isSentiment(TKN_ID, MARKABLE_141); features of the form
    # Sentiment::markable_141::Polarity=Positive should be converted to
    # hasSentimentPolarity(MARKABLE_141, POSITIVE)
    if FEAT_NAME_SEP_RE.search(fname):
        markname, markid, markattr = fname.split(FEAT_NAME_SEP)
        if markid:
            markid = '"' + markid + '"'
            if markname == markattr:
                foutput.fprint(IS_FEAT_PRFX + markname.title() + '(' + tkn_id + ", " + \
                                   markid.upper() + ')')
            else:
                foutput.fprint(HAS_FEAT_PRFX + markname.title() + markattr.title() + '(' + \
                                   markid.upper() + ", " + fvalue.upper() + ')')
    else:
        foutput.fprint(IS_FEAT_PRFX + fname.title() + '(' + tkn_id + ", " + \
                           fvalue.upper() + ')')

def __print_feat_mln_test__(foutput, tkn_id, fname, fvalue):
    """Output features from test data."""
    foutput.fprint(IS_FEAT_PRFX + fname.title() + '(' + tkn_id + ", " + \
                       fvalue.upper() + ')')

def __print_crf__(foutput, tkn_id, prnt_id, conll_w):
    """Output data in CRF format."""
    featdict = conll_w.pfeat
    foutput.fprint(conll_w.lemma + CONLL_FIELD_SEP + conll_w.ppos + \
                       CONLL_FIELD_SEP + conll_w.phead + \
                       CONLL_FIELD_SEP + conll_w.pdeprel + \
                       CONLL_FIELD_SEP + __crf_conllfeat2str__(featdict) + \
                       CONLL_FIELD_SEP + __crf_mmaxfeat2str__(featdict))

def __crf_conllfeat2str__(featdict):
    """Convert features to CRF format."""
    ostring = ""
    DEF_FEAT = "None"
    ostring += "Case" + featdict.get("case", DEF_FEAT) + CONLL_FIELD_SEP
    ostring += "Gender" + featdict.get("gender", DEF_FEAT) + CONLL_FIELD_SEP
    ostring += "Number" + featdict.get("number", DEF_FEAT) + CONLL_FIELD_SEP
    ostring += "Mood" + featdict.get("mood", DEF_FEAT) + CONLL_FIELD_SEP
    ostring += "Tense" + featdict.get("tense", DEF_FEAT) + CONLL_FIELD_SEP
    ostring += "Degree" + featdict.get("degree", DEF_FEAT) + CONLL_FIELD_SEP
    ostring += "IsEmoExpression" + featdict.get("EmoExpression", DEF_FEAT)
    return ostring

def __crf_mmaxfeat2str__(featdict):
    """Convert features to CRF format."""
    ostring = ""
    global sentiment_seen
    issentiment = ("Sentiment" in featdict)
    istarget = ("Target" in featdict)
    if issentiment:
        if sentiment_seen:
            ostring = "I-Sentiment"
        else:
            ostring = "B-Sentiment"
        sentiment_seen = True
    else:
        sentiment_seen = False
        ostring = "O"
    return ostring

def __crf_adjust_feat__(ifeature):
    """ """
    pass

##################################################################
# Processing Arguments
argparser.description="""Utility for for converting the CONLL format to format
appropriate for particular machine-learning package."""
argparser.add_argument("-c", "--esc-char", help = """escape character which
should precede lines with meta-information""", nargs = 1, type = str, \
                           default = os.environ.get("SOCMEDIA_ESC_CHAR", ""))
argparser.add_argument("--crf", help = """convert CONLL to the CRF format""",
                       action = "store_true")
argparser.add_argument("--mln", "-m", help = """convert CONLL to the MLN format (DEFAULT)""",
                       action = "store_true")
argparser.add_argument("--test", help = """convert CONLL to DB format in test
mode (another word prefix will be used then)""", action = "store_true")
args = argparser.parse_args()

if args.crf:
    print_func = __print_crf__
else:
    print_func = __print_mln__
    __print_feat_func__ = __print_feat_mln_train__

if args.test:
    tknprfx = TKN_PRFX_TEST
    __print_feat_func__ = __print_feat_mln_test__

##################################################################
# Main Body
mln      = args.mln
esc_char = args.esc_char
snt_id   = '0'
empty_seen = True
tkn_id = prnt_id = 0
conll_w = CONLLWord()
foutput = AltFileOutput(encoding = args.encoding, \
                            flush = args.flush)
finput = AltFileInput(*args.files, \
                           print_func = foutput.fprint)

for line in finput:
    # skip empty lines and lines beginning with the escape character, but
    # update `snt_id`
    if not line or line[0] == esc_char:
        sentiment_seen = False
        if not empty_seen:
            empty_seen = True
            if mln:
                foutput.fprint(ROOT_NODE.format(r_id = snt_id))
            snt_id = str(int(snt_id) + 1)
        if not line:
            foutput.fprint()
        continue
    # remeber that we have seen a line which was not empty
    empty_seen = False
    # parse line as a CONLL word
    conll_w.parse_line(line)
    # get unique token id of current token
    tkn_id  = tknprfx + snt_id + TKN_ID_SEP + conll_w.idx
    # get unique token id of parent token
    prnt_id = tknprfx + snt_id + TKN_ID_SEP + conll_w.head
    # output data in appropriate format
    print_func(foutput, tkn_id, prnt_id, conll_w)

if mln and not empty_seen:
    foutput.fprint(ROOT_NODE.format(r_id = snt_id))
