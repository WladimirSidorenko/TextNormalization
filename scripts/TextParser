#!/usr/bin/env bash
# -*- mode: shell-script; -*-
set -e -o pipefail

##################################################################
# Constants and Variables
MSG_DELIM_HEAD='1	END_OF_TWEET	END_OF_TWEET	END_OF_TWEET	NN	NN'
MSG_DELIM_RE="^${MSG_DELIM_HEAD}"
MSG_DELIM="${MSG_DELIM_HEAD}	_	_	_	_	_	_	_	_	_"
MSG_REPL='__TWEET__'

tagger=TextTagger

__cmd_prefix=''
__glob_opts=''

##################################################################
# Functions
usage() {
    local name="$(basename $0)"
    cat <<EOF >&2
DESCRIPTION:
${name} performs POS tagging of input lines and assigns sentiment
classes along with their probabilities to single words of input.

USAGE:
${name} [OPTIONS] [FILE(s)]

OPTIONS:
-h,--help    print this screen and exit
-f,--flush   flush output (be cautious, since TreeTagger doesn't
             support flushing, this option will only affect preceding
             modules but won't have any effect on the whole pipeline
             so far)
-s,--skip-line LINE    don't change input lines equal to LINE
-t|--tagged-input    accept tagged input
EOF
    exit ${1:-1}
}

dummy_tagger() {
    gawk '
    BEGIN {
        flushflag = 0
        for (i = 1; i < ARGC; ++i) {
            if (ARGV[i] ~ /^-f$/ || ARGV[i] ~ /^--flush$/) {
               flushflag = 1
            } else if ((ARGV[i] ~ /^-s$/ || ARGV[i] ~ /^--skip-line$/) && i < (ARGC - 1)) {
                ARGV[i++] = ""
            } else if (ARGV[i] ~ /^-s/ || ARGV[i] ~ /^--skip-line/) {
            } else if (ARGV[i] == "--") {
                ARGV[i] = ""
                break
            } else {
                break
            }
            ARGV[i] = ""
        }
    }

    1 {
        print
        if (flushflag)
            fflush()
    }' $@
}

tagged2conll() {
    gawk -v eos_tag="$(cat ${SOCMEDIA_LSRC}/sentence_splitter/eos.tag)" \
	-v nfields=15 -v MSG_DELIM="${MSG_DELIM}" -v  MSG_REPL="${MSG_REPL}" '
    function print_flush(iline) {
        print iline
        if (flushflag)
          fflush()
    }

    BEGIN {
        RS  = "\r?\n"
        ORS = "\n"
        FS = OFS = "\t"
        iline = 0
        skip      = 0
        skip_line = ""
        redirect_xml = 0
        flushflag = 0

        for (i = 1; i < ARGC; ++i) {
            if (ARGV[i] ~ /^-f$/ || ARGV[i] ~ /^--flush$/) {
               flushflag = 1
            } else if (ARGV[i] ~ /^-X$/) {
                ARGV[i] = ""
                redirect_xml = ARGV[++i]
                // zero out file
                printf("") > redirect_xml;
            } else if ((ARGV[i] ~ /^-s$/ || ARGV[i] ~ /^--skip-line$/) && i < (ARGC - 1)) {
                ARGV[i] = ""
                skip = 1; skip_line = ARGV[++i]
            } else if (match(ARGV[i], /^--skip-line=(.*)$/, tmp_arr)) {
                skip = 1; skip_line = tmp_arr[1]
            } else if (ARGV[i] == "--") {
                ARGV[i] = ""
                break
            } else {
                break
            }
            ARGV[i] = ""
        }
    }

    skip && $0 == skip_line {
       print_flush($0)
       next
    }

    $0 == eos_tag {
        print_flush("")
        print_flush(MSG_DELIM)
        print_flush("")

        print MSG_REPL >> redirect_xml
        print $0 >> redirect_xml

        iline = 0
        next
    }

    redirect_xml && $0 ~ /^[[:blank:]]*(<[^<>]+>[[:blank:]]*)+$/ {
       print $0 >> redirect_xml
       next
    }

    NF {
       word   = $1
       postag = $2
       lemma  = $3

       $1 = ++iline; $2 = word; $3 = $4 = lemma;
       $5 = $6 = postag
       for (j=7; j <= nfields; ++j) {
           $j = "_"
       }
       print
   }' $@
}

join_xml_conll() {
    gawk  -v MSG_DELIM_RE="${MSG_DELIM_RE}" -v MSG_REPL="${MSG_REPL}" '
    function print_flush(iline) {
        print iline
        if (flushflag)
          fflush()
    }

    function output_xml( \
                        ret) {
        while ((ret = getline < xml_file) > 0) {
            if ($0 == MSG_REPL)
                break
            else
                print_flush($0)
        }
        if (ret < 0) {
           print "Error while reading XML file \x27" xml_file "\x27" > "/dev/stderr"
           exit_status = 3
           exit 3;
        }
    }

    BEGIN {
        if (ARGC == 1) {
           exit_status = 2
           exit 2;
        }

        FS = "\t"
        flushflag = 0
        print_state = 0
        ret = 0
        exit_status = 0

        xml_file = ARGV[1]
        ARGV[1] = ""
        for (i = 2; i < ARGC; ++i) {
            if (ARGV[i] ~ /^-f$/ || ARGV[i] ~ /^--flush$/) {
               flushflag = 1
            } else if (ARGV[i] ~ /^-X$/) {
                ARGV[i] = ""
                redirect_xml = ARGV[++i]
                // zero out file
                printf("") > redirect_xml;
            } else if ((ARGV[i] ~ /^-s$/ || ARGV[i] ~ /^--skip-line$/) && i < (ARGC - 1)) {
                ARGV[i] = ""
                skip = 1; skip_line = ARGV[++i]
            } else if (match(ARGV[i], /^--skip-line=(.*)$/, tmp_arr)) {
                skip = 1; skip_line = tmp_arr[1]
            } else if (ARGV[i] == "--") {
                ARGV[i] = ""
                break
            } else {
                break
            }
            ARGV[i] = ""
        }
        output_xml()
    }

    $0 == skip_line {
        print_flush(iline)
        next
    }

    $0 ~ MSG_DELIM_RE {
        # read and output data from XML file until exhausted or
        # MSG_REPL is encountered
        output_xml()
        next
    }

    NF

    END {
        if (! exit_status)
            output_xml()
    }' $@
}

##################################################################
# Arguments
while test $# -gt 0; do
    case $1 in
	-h|--help)
	    usage 0;;
	-f|--flush)
	    __glob_opts="${__opts} ${1}";;
	-s|--skip-line)
	    if test $# -lt 2; then
		echo '-s,--skip-line requires an argument.' >&2
		exit 1
	    fi
	    __opts="${__opts} ${1} '${2}'"
	    # need `eval' to provide correct parsing of arguments
	    __cmd_prefix='eval'
	    shift;;
	-s*|--skip-line=*)
	    __glob_opts="${__opts} '${1}'"
	    __cmd_prefix='eval';;
	-t|--tagged-input)
	    tagger=dummy_tagger;;
	--)
	    shift
	    break;;
	-)
	    break;;
	-*)
	    echo "Unrecognized option '$1'. Type --help to see usage." >&2
	    exit 2;;
	*)
	    break;
    esac
    shift
done

##################################################################
# Main Pipeline

# create temporary file for stroing annotation
xml_file="$(mktemp -p ${SOCMEDIA_TMP} xml_annotation.XXXXXX)"
parser_output_file="$(mktemp -p ${SOCMEDIA_TMP} parser_output.XXXXXX)"
# delete temporary file on exit
trap 'rm -f ${xml_file} ${parser_output_file}' ERR EXIT

# Feed input data to parser but temporarily re-direct XML annotation
# to a temporary file joining the whole thing at the end
${__cmd_prefix} ${tagger} ${__glob_opts} $@ | \
    ${__cmd_prefix} tagged2conll ${__glob_opts} -X "${xml_file}" | \
    {
    # need to fiddle with file descriptors, since morphtagger sends
    # its debug info to stdout by default
    exec 6>&1
    java -Xmx2G -cp ${SOCMEDIA_MPARSER_DIR}/anna-3.3.jar is2.mtag.Tagger \
    	-model ${SOCMEDIA_MPARSER_DIR}/tiger-complete.anna-3-1.morphtagger.model \
    	-test /dev/stdin -out /dev/fd/6 6>&1 1>&2 | \
	java -Xmx3G -cp ${SOCMEDIA_MPARSER_DIR}/anna-3.3.jar is2.parser.Parser \
	-model ${SOCMEDIA_MPARSER_DIR}/tiger-complete.anna-3-1.parser.model \
	-test /dev/stdin -out /dev/fd/6 6>&1 1>&2
    exec 1>&6 6>&-; } > ${parser_output_file}

${__cmd_prefix} join_xml_conll "${xml_file}" ${__glob_opts} < "${parser_output_file}"
