#!/usr/bin/env bash
# -*- mode: shell-script; -*-
set -e -o pipefail

##################################################################
# Variables
__cmd_prefix=''
__glob_opts=''

tagger=TextTagger

##################################################################
# Functions
usage() {
    local name="$(basename $0)"
    cat <<EOF >&2
DESCRIPTION:
${name} performs POS tagging of input lines and assigns sentiment
classes along with their probabilities to single words of input.

USAGE:
${name} [OPTIONS] [FILE(s)]

OPTIONS:
-h,--help    print this screen and exit
-f,--flush   flush output (be cautious, since TreeTagger doesn't
             support flushing, this option will only affect preceding
             modules but won't have any effect on the whole pipeline
             so far)
-s,--skip-line LINE    don't change input lines equal to LINE
-t|--tagged-input    accept tagged input
EOF
    exit ${1:-1}
}

dummy_tagger() {
    gawk '
    BEGIN {
        flushflag = 0
        for (i = 1; i < ARGC; ++i) {
            if (ARGV[i] ~ /^-f$/ || ARGV[i] ~ /^--flush$/) {
               ARGV[i] = ""
               flushflag = 1
            } else if ((ARGV[i] ~ /^-s$/ || ARGV[i] ~ /^--skip-line$/) && i < (ARGC - 1)) {
                ARGV[i] = ""; ARGV[i+1] = ""
            } else if (ARGV[i] ~ /^-s/ || ARGV[i] ~ /^--skip-line/) {
                ARGV[i] = ""
            } else if (ARGV[i] == "") {
                ARGV[i] = ""
            } else {
                break
            }
        }
    }

    1 {
        print
        if (flushflag)
            fflush()
    }' $@
}

tagged2conll() {
    gawk -v eos_tag="$(cat ${SOCMEDIA_LSRC}/sentence_splitter/eos.tag)" \
	-v nfields=15 '
    function print_flush(iline) {
        print iline
        if (flushflag)
          fflush()
    }

    BEGIN {
        RS  = "\r?\n"
        ORS = "\n"
        FS = OFS = "\t"
        iline = 0
        skip      = 0
        skip_line = ""
        prune_xml = 0
        flushflag = 0

        for (i = 1; i < ARGC; ++i) {
            if (ARGV[i] ~ /^-f$/ || ARGV[i] ~ /^--flush$/) {
               ARGV[i] = ""
               flushflag = 1
            } else if (ARGV[i] ~ /^-X$/) {
                prune_xml = 1
                ARGV[i] = ""
            } else if ((ARGV[i] ~ /^-s$/ || ARGV[i] ~ /^--skip-line$/) && i < (ARGC - 1)) {
                ARGV[i] = ""
                skip = 1; skip_line = ARGV[i+1]
                ARGV[i+1] = ""
            } else if (match(ARGV[i], /^--skip-line=(.*)$/, tmp_arr)) {
                skip = 1; skip_line = tmp_arr[1]
                ARGV[i] = ""
            } else if (ARGV[i] == "--") {
                ARGV[i] = ""
                break
            } else {
                break
            }
        }
    }

    skip && $0 == skip_line {
       print_flush($0)
       next
    }

    $0 == eos_tag {
        print_flush("")
        iline = 0
        next
    }

    prune_xml && $0 ~ /^[[:blank:]]*(<[^<>]+>[[:blank:]]*)+$/ {
       next
    }

    NF {
       word   = $1
       postag = $2
       lemma  = $3

       $1 = ++iline; $2 = word; $3 = $4 = lemma;
       $5 = $6 = postag
       for (j=7; j <= nfields; ++j) {
           $j = "_"
       }
       print
   }' $@
}

##################################################################
# Arguments
while test $# -gt 0; do
    case $1 in
	-h|--help)
	    usage 0;;
	-f|--flush)
	    __glob_opts="${__opts} ${1}";;
	-s|--skip-line)
	    if test $# -lt 2; then
		echo '-s,--skip-line requires an argument.' >&2
		exit 1
	    fi
	    __opts="${__opts} ${1} '${2}'"
	    # need `eval' to provide correct parsing of arguments
	    __cmd_prefix='eval'
	    shift;;
	-s*|--skip-line=*)
	    __glob_opts="${__opts} '${1}'"
	    __cmd_prefix='eval';;
	-t|--tagged-input)
	    tagger=dummy_tagger;;
	--)
	    shift
	    break;;
	-)
	    break;;
	-*)
	    echo "Unrecognized option '$1'. Type --help to see usage." >&2
	    exit 2;;
	*)
	    break;
    esac
    shift
done

##################################################################
# Main Pipeline

# Creating a named pipe for communication between morphtagger and
# dependency parser
${__cmd_prefix} ${tagger} ${__glob_opts} $@ | \
    ${__cmd_prefix} tagged2conll -X ${__glob_opts} | \
    {
    # need to fiddle with file descriptors, since morphtagger sends
    # its debug info to stdout by default
    exec 6>&1
    java -Xmx2G -cp ${SOCMEDIA_MPARSER_DIR}/anna-3.3.jar is2.mtag.Tagger \
    	-model ${SOCMEDIA_MPARSER_DIR}/tiger-complete.anna-3-1.morphtagger.model \
    	-test /dev/stdin -out /dev/fd/6 6>&1 1>&2 | \
    java -Xmx3G -cp ${SOCMEDIA_MPARSER_DIR}/anna-3.3.jar is2.parser.Parser \
    -model ${SOCMEDIA_MPARSER_DIR}/tiger-complete.anna-3-1.parser.model \
    -test /dev/stdin -out /dev/fd/6 6>&1 1>&2
    exec 1>&6 6>&-
    }
